/**
 * Generated by orval v7.20.0 üç∫
 * Do not edit manually.
 * @ding/api
 * Ding API Documentation
 * OpenAPI spec version: 0.0.0
 */
import { useMutation, useQuery } from '@tanstack/react-query'
import { customFetch } from '../../fetcher'
import type {
  CreateApplication201,
  CreateApplication400,
  CreateApplication404,
  CreateApplication500,
  CreateApplicationBody,
  GetApplication200,
  GetApplication500,
  MarkConsentChecked200,
  MarkConsentChecked400,
  MarkConsentChecked404,
  MarkConsentChecked500,
  MarkExtractionReviewed200,
  MarkExtractionReviewed400,
  MarkExtractionReviewed404,
  MarkExtractionReviewed500,
  SaveApplicationExtractedField201,
  SaveApplicationExtractedField400,
  SaveApplicationExtractedField404,
  SaveApplicationExtractedField500,
  SaveApplicationExtractedFieldBody,
  SubmitApplication200,
  SubmitApplication400,
  SubmitApplication500,
  TriggerManualFallback200,
  TriggerManualFallback404,
  TriggerManualFallback500,
  UpdateApplicationExtractedField200,
  UpdateApplicationExtractedField404,
  UpdateApplicationExtractedField500,
  UpdateApplicationExtractedFieldBody,
  UpdateApplicationStatus200,
  UpdateApplicationStatus400,
  UpdateApplicationStatus500,
  UpdateApplicationStatusBody,
} from '.././models'
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query'

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1]

/**
 * @summary Create a new application
 */
export const createApplication = (
  createApplicationBody: CreateApplicationBody,
  options?: SecondParameter<typeof customFetch>,
  signal?: AbortSignal
) => {
  return customFetch<CreateApplication201>(
    {
      url: `API_BASE_URL/api/applications`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: createApplicationBody,
      signal,
    },
    options
  )
}

export const getCreateApplicationMutationOptions = <
  TError = CreateApplication400 | CreateApplication404 | CreateApplication500,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createApplication>>,
    TError,
    { data: CreateApplicationBody },
    TContext
  >
  request?: SecondParameter<typeof customFetch>
}): UseMutationOptions<
  Awaited<ReturnType<typeof createApplication>>,
  TError,
  { data: CreateApplicationBody },
  TContext
> => {
  const mutationKey = ['createApplication']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createApplication>>,
    { data: CreateApplicationBody }
  > = (props) => {
    const { data } = props ?? {}

    return createApplication(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateApplicationMutationResult = NonNullable<
  Awaited<ReturnType<typeof createApplication>>
>
export type CreateApplicationMutationBody = CreateApplicationBody
export type CreateApplicationMutationError =
  | CreateApplication400
  | CreateApplication404
  | CreateApplication500

/**
 * @summary Create a new application
 */
export const useCreateApplication = <
  TError = CreateApplication400 | CreateApplication404 | CreateApplication500,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createApplication>>,
      TError,
      { data: CreateApplicationBody },
      TContext
    >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createApplication>>,
  TError,
  { data: CreateApplicationBody },
  TContext
> => {
  const mutationOptions = getCreateApplicationMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * @summary Get an application by ID
 */
export const getApplication = (
  applicationId: string,
  options?: SecondParameter<typeof customFetch>,
  signal?: AbortSignal
) => {
  return customFetch<GetApplication200>(
    { url: `API_BASE_URL/api/applications/${applicationId}`, method: 'GET', signal },
    options
  )
}

export const getGetApplicationQueryKey = (applicationId?: string) => {
  return [`API_BASE_URL/api/applications/${applicationId}`] as const
}

export const getGetApplicationQueryOptions = <
  TData = Awaited<ReturnType<typeof getApplication>>,
  TError = GetApplication500,
>(
  applicationId: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getApplication>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetApplicationQueryKey(applicationId)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getApplication>>> = ({ signal }) =>
    getApplication(applicationId, requestOptions, signal)

  return { queryKey, queryFn, enabled: !!applicationId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getApplication>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetApplicationQueryResult = NonNullable<Awaited<ReturnType<typeof getApplication>>>
export type GetApplicationQueryError = GetApplication500

export function useGetApplication<
  TData = Awaited<ReturnType<typeof getApplication>>,
  TError = GetApplication500,
>(
  applicationId: string,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getApplication>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApplication>>,
          TError,
          Awaited<ReturnType<typeof getApplication>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApplication<
  TData = Awaited<ReturnType<typeof getApplication>>,
  TError = GetApplication500,
>(
  applicationId: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getApplication>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApplication>>,
          TError,
          Awaited<ReturnType<typeof getApplication>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApplication<
  TData = Awaited<ReturnType<typeof getApplication>>,
  TError = GetApplication500,
>(
  applicationId: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getApplication>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get an application by ID
 */

export function useGetApplication<
  TData = Awaited<ReturnType<typeof getApplication>>,
  TError = GetApplication500,
>(
  applicationId: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getApplication>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetApplicationQueryOptions(applicationId, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Update application status
 */
export const updateApplicationStatus = (
  applicationId: string,
  updateApplicationStatusBody: UpdateApplicationStatusBody,
  options?: SecondParameter<typeof customFetch>
) => {
  return customFetch<UpdateApplicationStatus200>(
    {
      url: `API_BASE_URL/api/applications/${applicationId}/status`,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      data: updateApplicationStatusBody,
    },
    options
  )
}

export const getUpdateApplicationStatusMutationOptions = <
  TError = UpdateApplicationStatus400 | UpdateApplicationStatus500,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateApplicationStatus>>,
    TError,
    { applicationId: string; data: UpdateApplicationStatusBody },
    TContext
  >
  request?: SecondParameter<typeof customFetch>
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateApplicationStatus>>,
  TError,
  { applicationId: string; data: UpdateApplicationStatusBody },
  TContext
> => {
  const mutationKey = ['updateApplicationStatus']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateApplicationStatus>>,
    { applicationId: string; data: UpdateApplicationStatusBody }
  > = (props) => {
    const { applicationId, data } = props ?? {}

    return updateApplicationStatus(applicationId, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateApplicationStatusMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateApplicationStatus>>
>
export type UpdateApplicationStatusMutationBody = UpdateApplicationStatusBody
export type UpdateApplicationStatusMutationError =
  | UpdateApplicationStatus400
  | UpdateApplicationStatus500

/**
 * @summary Update application status
 */
export const useUpdateApplicationStatus = <
  TError = UpdateApplicationStatus400 | UpdateApplicationStatus500,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateApplicationStatus>>,
      TError,
      { applicationId: string; data: UpdateApplicationStatusBody },
      TContext
    >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateApplicationStatus>>,
  TError,
  { applicationId: string; data: UpdateApplicationStatusBody },
  TContext
> => {
  const mutationOptions = getUpdateApplicationStatusMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * @summary Submit an application
 */
export const submitApplication = (
  applicationId: string,
  options?: SecondParameter<typeof customFetch>,
  signal?: AbortSignal
) => {
  return customFetch<SubmitApplication200>(
    { url: `API_BASE_URL/api/applications/${applicationId}/submit`, method: 'POST', signal },
    options
  )
}

export const getSubmitApplicationMutationOptions = <
  TError = SubmitApplication400 | SubmitApplication500,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof submitApplication>>,
    TError,
    { applicationId: string },
    TContext
  >
  request?: SecondParameter<typeof customFetch>
}): UseMutationOptions<
  Awaited<ReturnType<typeof submitApplication>>,
  TError,
  { applicationId: string },
  TContext
> => {
  const mutationKey = ['submitApplication']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof submitApplication>>,
    { applicationId: string }
  > = (props) => {
    const { applicationId } = props ?? {}

    return submitApplication(applicationId, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type SubmitApplicationMutationResult = NonNullable<
  Awaited<ReturnType<typeof submitApplication>>
>

export type SubmitApplicationMutationError = SubmitApplication400 | SubmitApplication500

/**
 * @summary Submit an application
 */
export const useSubmitApplication = <
  TError = SubmitApplication400 | SubmitApplication500,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof submitApplication>>,
      TError,
      { applicationId: string },
      TContext
    >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof submitApplication>>,
  TError,
  { applicationId: string },
  TContext
> => {
  const mutationOptions = getSubmitApplicationMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * @summary Save an extracted field for an application
 */
export const saveApplicationExtractedField = (
  applicationId: string,
  saveApplicationExtractedFieldBody: SaveApplicationExtractedFieldBody,
  options?: SecondParameter<typeof customFetch>,
  signal?: AbortSignal
) => {
  return customFetch<SaveApplicationExtractedField201>(
    {
      url: `API_BASE_URL/api/applications/${applicationId}/extracted-fields`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: saveApplicationExtractedFieldBody,
      signal,
    },
    options
  )
}

export const getSaveApplicationExtractedFieldMutationOptions = <
  TError =
    | SaveApplicationExtractedField400
    | SaveApplicationExtractedField404
    | SaveApplicationExtractedField500,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof saveApplicationExtractedField>>,
    TError,
    { applicationId: string; data: SaveApplicationExtractedFieldBody },
    TContext
  >
  request?: SecondParameter<typeof customFetch>
}): UseMutationOptions<
  Awaited<ReturnType<typeof saveApplicationExtractedField>>,
  TError,
  { applicationId: string; data: SaveApplicationExtractedFieldBody },
  TContext
> => {
  const mutationKey = ['saveApplicationExtractedField']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof saveApplicationExtractedField>>,
    { applicationId: string; data: SaveApplicationExtractedFieldBody }
  > = (props) => {
    const { applicationId, data } = props ?? {}

    return saveApplicationExtractedField(applicationId, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type SaveApplicationExtractedFieldMutationResult = NonNullable<
  Awaited<ReturnType<typeof saveApplicationExtractedField>>
>
export type SaveApplicationExtractedFieldMutationBody = SaveApplicationExtractedFieldBody
export type SaveApplicationExtractedFieldMutationError =
  | SaveApplicationExtractedField400
  | SaveApplicationExtractedField404
  | SaveApplicationExtractedField500

/**
 * @summary Save an extracted field for an application
 */
export const useSaveApplicationExtractedField = <
  TError =
    | SaveApplicationExtractedField400
    | SaveApplicationExtractedField404
    | SaveApplicationExtractedField500,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof saveApplicationExtractedField>>,
      TError,
      { applicationId: string; data: SaveApplicationExtractedFieldBody },
      TContext
    >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof saveApplicationExtractedField>>,
  TError,
  { applicationId: string; data: SaveApplicationExtractedFieldBody },
  TContext
> => {
  const mutationOptions = getSaveApplicationExtractedFieldMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * @summary Update an extracted field value
 */
export const updateApplicationExtractedField = (
  applicationId: string,
  fieldId: string,
  updateApplicationExtractedFieldBody: UpdateApplicationExtractedFieldBody,
  options?: SecondParameter<typeof customFetch>
) => {
  return customFetch<UpdateApplicationExtractedField200>(
    {
      url: `API_BASE_URL/api/applications/${applicationId}/extracted-fields/${fieldId}`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: updateApplicationExtractedFieldBody,
    },
    options
  )
}

export const getUpdateApplicationExtractedFieldMutationOptions = <
  TError = UpdateApplicationExtractedField404 | UpdateApplicationExtractedField500,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateApplicationExtractedField>>,
    TError,
    { applicationId: string; fieldId: string; data: UpdateApplicationExtractedFieldBody },
    TContext
  >
  request?: SecondParameter<typeof customFetch>
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateApplicationExtractedField>>,
  TError,
  { applicationId: string; fieldId: string; data: UpdateApplicationExtractedFieldBody },
  TContext
> => {
  const mutationKey = ['updateApplicationExtractedField']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateApplicationExtractedField>>,
    { applicationId: string; fieldId: string; data: UpdateApplicationExtractedFieldBody }
  > = (props) => {
    const { applicationId, fieldId, data } = props ?? {}

    return updateApplicationExtractedField(applicationId, fieldId, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateApplicationExtractedFieldMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateApplicationExtractedField>>
>
export type UpdateApplicationExtractedFieldMutationBody = UpdateApplicationExtractedFieldBody
export type UpdateApplicationExtractedFieldMutationError =
  | UpdateApplicationExtractedField404
  | UpdateApplicationExtractedField500

/**
 * @summary Update an extracted field value
 */
export const useUpdateApplicationExtractedField = <
  TError = UpdateApplicationExtractedField404 | UpdateApplicationExtractedField500,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateApplicationExtractedField>>,
      TError,
      { applicationId: string; fieldId: string; data: UpdateApplicationExtractedFieldBody },
      TContext
    >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateApplicationExtractedField>>,
  TError,
  { applicationId: string; fieldId: string; data: UpdateApplicationExtractedFieldBody },
  TContext
> => {
  const mutationOptions = getUpdateApplicationExtractedFieldMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * @summary Trigger manual fallback for an application
 */
export const triggerManualFallback = (
  applicationId: string,
  options?: SecondParameter<typeof customFetch>,
  signal?: AbortSignal
) => {
  return customFetch<TriggerManualFallback200>(
    {
      url: `API_BASE_URL/api/applications/${applicationId}/manual-fallback`,
      method: 'POST',
      signal,
    },
    options
  )
}

export const getTriggerManualFallbackMutationOptions = <
  TError = TriggerManualFallback404 | TriggerManualFallback500,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof triggerManualFallback>>,
    TError,
    { applicationId: string },
    TContext
  >
  request?: SecondParameter<typeof customFetch>
}): UseMutationOptions<
  Awaited<ReturnType<typeof triggerManualFallback>>,
  TError,
  { applicationId: string },
  TContext
> => {
  const mutationKey = ['triggerManualFallback']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof triggerManualFallback>>,
    { applicationId: string }
  > = (props) => {
    const { applicationId } = props ?? {}

    return triggerManualFallback(applicationId, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type TriggerManualFallbackMutationResult = NonNullable<
  Awaited<ReturnType<typeof triggerManualFallback>>
>

export type TriggerManualFallbackMutationError = TriggerManualFallback404 | TriggerManualFallback500

/**
 * @summary Trigger manual fallback for an application
 */
export const useTriggerManualFallback = <
  TError = TriggerManualFallback404 | TriggerManualFallback500,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof triggerManualFallback>>,
      TError,
      { applicationId: string },
      TContext
    >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof triggerManualFallback>>,
  TError,
  { applicationId: string },
  TContext
> => {
  const mutationOptions = getTriggerManualFallbackMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * @summary Mark extraction as reviewed
 */
export const markExtractionReviewed = (
  applicationId: string,
  options?: SecondParameter<typeof customFetch>
) => {
  return customFetch<MarkExtractionReviewed200>(
    { url: `API_BASE_URL/api/applications/${applicationId}/extraction-reviewed`, method: 'PATCH' },
    options
  )
}

export const getMarkExtractionReviewedMutationOptions = <
  TError = MarkExtractionReviewed400 | MarkExtractionReviewed404 | MarkExtractionReviewed500,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof markExtractionReviewed>>,
    TError,
    { applicationId: string },
    TContext
  >
  request?: SecondParameter<typeof customFetch>
}): UseMutationOptions<
  Awaited<ReturnType<typeof markExtractionReviewed>>,
  TError,
  { applicationId: string },
  TContext
> => {
  const mutationKey = ['markExtractionReviewed']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof markExtractionReviewed>>,
    { applicationId: string }
  > = (props) => {
    const { applicationId } = props ?? {}

    return markExtractionReviewed(applicationId, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type MarkExtractionReviewedMutationResult = NonNullable<
  Awaited<ReturnType<typeof markExtractionReviewed>>
>

export type MarkExtractionReviewedMutationError =
  | MarkExtractionReviewed400
  | MarkExtractionReviewed404
  | MarkExtractionReviewed500

/**
 * @summary Mark extraction as reviewed
 */
export const useMarkExtractionReviewed = <
  TError = MarkExtractionReviewed400 | MarkExtractionReviewed404 | MarkExtractionReviewed500,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof markExtractionReviewed>>,
      TError,
      { applicationId: string },
      TContext
    >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof markExtractionReviewed>>,
  TError,
  { applicationId: string },
  TContext
> => {
  const mutationOptions = getMarkExtractionReviewedMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * @summary Mark consent as checked
 */
export const markConsentChecked = (
  applicationId: string,
  options?: SecondParameter<typeof customFetch>
) => {
  return customFetch<MarkConsentChecked200>(
    { url: `API_BASE_URL/api/applications/${applicationId}/consent-checked`, method: 'PATCH' },
    options
  )
}

export const getMarkConsentCheckedMutationOptions = <
  TError = MarkConsentChecked400 | MarkConsentChecked404 | MarkConsentChecked500,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof markConsentChecked>>,
    TError,
    { applicationId: string },
    TContext
  >
  request?: SecondParameter<typeof customFetch>
}): UseMutationOptions<
  Awaited<ReturnType<typeof markConsentChecked>>,
  TError,
  { applicationId: string },
  TContext
> => {
  const mutationKey = ['markConsentChecked']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof markConsentChecked>>,
    { applicationId: string }
  > = (props) => {
    const { applicationId } = props ?? {}

    return markConsentChecked(applicationId, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type MarkConsentCheckedMutationResult = NonNullable<
  Awaited<ReturnType<typeof markConsentChecked>>
>

export type MarkConsentCheckedMutationError =
  | MarkConsentChecked400
  | MarkConsentChecked404
  | MarkConsentChecked500

/**
 * @summary Mark consent as checked
 */
export const useMarkConsentChecked = <
  TError = MarkConsentChecked400 | MarkConsentChecked404 | MarkConsentChecked500,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof markConsentChecked>>,
      TError,
      { applicationId: string },
      TContext
    >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof markConsentChecked>>,
  TError,
  { applicationId: string },
  TContext
> => {
  const mutationOptions = getMarkConsentCheckedMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
