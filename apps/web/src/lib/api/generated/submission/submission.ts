/**
 * Generated by orval v7.20.0 üç∫
 * Do not edit manually.
 * @ding/api
 * Ding API Documentation
 * OpenAPI spec version: 0.0.0
 */
import { useMutation, useQuery } from '@tanstack/react-query'
import { customFetch } from '../../fetcher'
import type {
  CreateSubmission201,
  CreateSubmission400,
  CreateSubmission404,
  CreateSubmission500,
  CreateSubmissionBody,
  GetSubmission200,
  GetSubmission404,
  GetSubmission500,
  MarkConsentChecked200,
  MarkConsentChecked400,
  MarkConsentChecked404,
  MarkConsentChecked500,
  MarkReviewCompleted200,
  MarkReviewCompleted400,
  MarkReviewCompleted404,
  MarkReviewCompleted500,
  SaveCollectedField201,
  SaveCollectedField404,
  SaveCollectedField500,
  SaveCollectedFieldBody,
  SubmitSubmission200,
  SubmitSubmission400,
  SubmitSubmission404,
  SubmitSubmission500,
  TriggerManualFallback200,
  TriggerManualFallback404,
  TriggerManualFallback500,
  UpdateCollectedField200,
  UpdateCollectedField404,
  UpdateCollectedField500,
  UpdateCollectedFieldBody,
  UpdateSubmissionStatus200,
  UpdateSubmissionStatus400,
  UpdateSubmissionStatus404,
  UpdateSubmissionStatus500,
  UpdateSubmissionStatusBody,
} from '.././models'
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query'

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1]

/**
 * @summary Create a new submission
 */
export const createSubmission = (
  createSubmissionBody: CreateSubmissionBody,
  options?: SecondParameter<typeof customFetch>,
  signal?: AbortSignal
) => {
  return customFetch<CreateSubmission201>(
    {
      url: `API_BASE_URL/api/submissions`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: createSubmissionBody,
      signal,
    },
    options
  )
}

export const getCreateSubmissionMutationOptions = <
  TError = CreateSubmission400 | CreateSubmission404 | CreateSubmission500,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createSubmission>>,
    TError,
    { data: CreateSubmissionBody },
    TContext
  >
  request?: SecondParameter<typeof customFetch>
}): UseMutationOptions<
  Awaited<ReturnType<typeof createSubmission>>,
  TError,
  { data: CreateSubmissionBody },
  TContext
> => {
  const mutationKey = ['createSubmission']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createSubmission>>,
    { data: CreateSubmissionBody }
  > = (props) => {
    const { data } = props ?? {}

    return createSubmission(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type CreateSubmissionMutationResult = NonNullable<
  Awaited<ReturnType<typeof createSubmission>>
>
export type CreateSubmissionMutationBody = CreateSubmissionBody
export type CreateSubmissionMutationError =
  | CreateSubmission400
  | CreateSubmission404
  | CreateSubmission500

/**
 * @summary Create a new submission
 */
export const useCreateSubmission = <
  TError = CreateSubmission400 | CreateSubmission404 | CreateSubmission500,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createSubmission>>,
      TError,
      { data: CreateSubmissionBody },
      TContext
    >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createSubmission>>,
  TError,
  { data: CreateSubmissionBody },
  TContext
> => {
  const mutationOptions = getCreateSubmissionMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * @summary Get a submission by ID
 */
export const getSubmission = (
  submissionId: string,
  options?: SecondParameter<typeof customFetch>,
  signal?: AbortSignal
) => {
  return customFetch<GetSubmission200>(
    { url: `API_BASE_URL/api/submissions/${submissionId}`, method: 'GET', signal },
    options
  )
}

export const getGetSubmissionQueryKey = (submissionId?: string) => {
  return [`API_BASE_URL/api/submissions/${submissionId}`] as const
}

export const getGetSubmissionQueryOptions = <
  TData = Awaited<ReturnType<typeof getSubmission>>,
  TError = GetSubmission404 | GetSubmission500,
>(
  submissionId: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubmission>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetSubmissionQueryKey(submissionId)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSubmission>>> = ({ signal }) =>
    getSubmission(submissionId, requestOptions, signal)

  return { queryKey, queryFn, enabled: !!submissionId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getSubmission>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSubmissionQueryResult = NonNullable<Awaited<ReturnType<typeof getSubmission>>>
export type GetSubmissionQueryError = GetSubmission404 | GetSubmission500

export function useGetSubmission<
  TData = Awaited<ReturnType<typeof getSubmission>>,
  TError = GetSubmission404 | GetSubmission500,
>(
  submissionId: string,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubmission>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSubmission>>,
          TError,
          Awaited<ReturnType<typeof getSubmission>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSubmission<
  TData = Awaited<ReturnType<typeof getSubmission>>,
  TError = GetSubmission404 | GetSubmission500,
>(
  submissionId: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubmission>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSubmission>>,
          TError,
          Awaited<ReturnType<typeof getSubmission>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSubmission<
  TData = Awaited<ReturnType<typeof getSubmission>>,
  TError = GetSubmission404 | GetSubmission500,
>(
  submissionId: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubmission>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a submission by ID
 */

export function useGetSubmission<
  TData = Awaited<ReturnType<typeof getSubmission>>,
  TError = GetSubmission404 | GetSubmission500,
>(
  submissionId: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubmission>>, TError, TData>>
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetSubmissionQueryOptions(submissionId, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Update submission status
 */
export const updateSubmissionStatus = (
  submissionId: string,
  updateSubmissionStatusBody: UpdateSubmissionStatusBody,
  options?: SecondParameter<typeof customFetch>
) => {
  return customFetch<UpdateSubmissionStatus200>(
    {
      url: `API_BASE_URL/api/submissions/${submissionId}/status`,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      data: updateSubmissionStatusBody,
    },
    options
  )
}

export const getUpdateSubmissionStatusMutationOptions = <
  TError = UpdateSubmissionStatus400 | UpdateSubmissionStatus404 | UpdateSubmissionStatus500,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateSubmissionStatus>>,
    TError,
    { submissionId: string; data: UpdateSubmissionStatusBody },
    TContext
  >
  request?: SecondParameter<typeof customFetch>
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateSubmissionStatus>>,
  TError,
  { submissionId: string; data: UpdateSubmissionStatusBody },
  TContext
> => {
  const mutationKey = ['updateSubmissionStatus']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateSubmissionStatus>>,
    { submissionId: string; data: UpdateSubmissionStatusBody }
  > = (props) => {
    const { submissionId, data } = props ?? {}

    return updateSubmissionStatus(submissionId, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateSubmissionStatusMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateSubmissionStatus>>
>
export type UpdateSubmissionStatusMutationBody = UpdateSubmissionStatusBody
export type UpdateSubmissionStatusMutationError =
  | UpdateSubmissionStatus400
  | UpdateSubmissionStatus404
  | UpdateSubmissionStatus500

/**
 * @summary Update submission status
 */
export const useUpdateSubmissionStatus = <
  TError = UpdateSubmissionStatus400 | UpdateSubmissionStatus404 | UpdateSubmissionStatus500,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateSubmissionStatus>>,
      TError,
      { submissionId: string; data: UpdateSubmissionStatusBody },
      TContext
    >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateSubmissionStatus>>,
  TError,
  { submissionId: string; data: UpdateSubmissionStatusBody },
  TContext
> => {
  const mutationOptions = getUpdateSubmissionStatusMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * @summary Submit a submission
 */
export const submitSubmission = (
  submissionId: string,
  options?: SecondParameter<typeof customFetch>,
  signal?: AbortSignal
) => {
  return customFetch<SubmitSubmission200>(
    { url: `API_BASE_URL/api/submissions/${submissionId}/submit`, method: 'POST', signal },
    options
  )
}

export const getSubmitSubmissionMutationOptions = <
  TError = SubmitSubmission400 | SubmitSubmission404 | SubmitSubmission500,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof submitSubmission>>,
    TError,
    { submissionId: string },
    TContext
  >
  request?: SecondParameter<typeof customFetch>
}): UseMutationOptions<
  Awaited<ReturnType<typeof submitSubmission>>,
  TError,
  { submissionId: string },
  TContext
> => {
  const mutationKey = ['submitSubmission']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof submitSubmission>>,
    { submissionId: string }
  > = (props) => {
    const { submissionId } = props ?? {}

    return submitSubmission(submissionId, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type SubmitSubmissionMutationResult = NonNullable<
  Awaited<ReturnType<typeof submitSubmission>>
>

export type SubmitSubmissionMutationError =
  | SubmitSubmission400
  | SubmitSubmission404
  | SubmitSubmission500

/**
 * @summary Submit a submission
 */
export const useSubmitSubmission = <
  TError = SubmitSubmission400 | SubmitSubmission404 | SubmitSubmission500,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof submitSubmission>>,
      TError,
      { submissionId: string },
      TContext
    >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof submitSubmission>>,
  TError,
  { submissionId: string },
  TContext
> => {
  const mutationOptions = getSubmitSubmissionMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * @summary Save a collected field
 */
export const saveCollectedField = (
  submissionId: string,
  saveCollectedFieldBody: SaveCollectedFieldBody,
  options?: SecondParameter<typeof customFetch>,
  signal?: AbortSignal
) => {
  return customFetch<SaveCollectedField201>(
    {
      url: `API_BASE_URL/api/submissions/${submissionId}/collected-fields`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: saveCollectedFieldBody,
      signal,
    },
    options
  )
}

export const getSaveCollectedFieldMutationOptions = <
  TError = SaveCollectedField404 | SaveCollectedField500,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof saveCollectedField>>,
    TError,
    { submissionId: string; data: SaveCollectedFieldBody },
    TContext
  >
  request?: SecondParameter<typeof customFetch>
}): UseMutationOptions<
  Awaited<ReturnType<typeof saveCollectedField>>,
  TError,
  { submissionId: string; data: SaveCollectedFieldBody },
  TContext
> => {
  const mutationKey = ['saveCollectedField']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof saveCollectedField>>,
    { submissionId: string; data: SaveCollectedFieldBody }
  > = (props) => {
    const { submissionId, data } = props ?? {}

    return saveCollectedField(submissionId, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type SaveCollectedFieldMutationResult = NonNullable<
  Awaited<ReturnType<typeof saveCollectedField>>
>
export type SaveCollectedFieldMutationBody = SaveCollectedFieldBody
export type SaveCollectedFieldMutationError = SaveCollectedField404 | SaveCollectedField500

/**
 * @summary Save a collected field
 */
export const useSaveCollectedField = <
  TError = SaveCollectedField404 | SaveCollectedField500,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof saveCollectedField>>,
      TError,
      { submissionId: string; data: SaveCollectedFieldBody },
      TContext
    >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof saveCollectedField>>,
  TError,
  { submissionId: string; data: SaveCollectedFieldBody },
  TContext
> => {
  const mutationOptions = getSaveCollectedFieldMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * @summary Update a collected field
 */
export const updateCollectedField = (
  submissionId: string,
  fieldId: string,
  updateCollectedFieldBody: UpdateCollectedFieldBody,
  options?: SecondParameter<typeof customFetch>
) => {
  return customFetch<UpdateCollectedField200>(
    {
      url: `API_BASE_URL/api/submissions/${submissionId}/collected-fields/${fieldId}`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: updateCollectedFieldBody,
    },
    options
  )
}

export const getUpdateCollectedFieldMutationOptions = <
  TError = UpdateCollectedField404 | UpdateCollectedField500,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateCollectedField>>,
    TError,
    { submissionId: string; fieldId: string; data: UpdateCollectedFieldBody },
    TContext
  >
  request?: SecondParameter<typeof customFetch>
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateCollectedField>>,
  TError,
  { submissionId: string; fieldId: string; data: UpdateCollectedFieldBody },
  TContext
> => {
  const mutationKey = ['updateCollectedField']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateCollectedField>>,
    { submissionId: string; fieldId: string; data: UpdateCollectedFieldBody }
  > = (props) => {
    const { submissionId, fieldId, data } = props ?? {}

    return updateCollectedField(submissionId, fieldId, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateCollectedFieldMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateCollectedField>>
>
export type UpdateCollectedFieldMutationBody = UpdateCollectedFieldBody
export type UpdateCollectedFieldMutationError = UpdateCollectedField404 | UpdateCollectedField500

/**
 * @summary Update a collected field
 */
export const useUpdateCollectedField = <
  TError = UpdateCollectedField404 | UpdateCollectedField500,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateCollectedField>>,
      TError,
      { submissionId: string; fieldId: string; data: UpdateCollectedFieldBody },
      TContext
    >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateCollectedField>>,
  TError,
  { submissionId: string; fieldId: string; data: UpdateCollectedFieldBody },
  TContext
> => {
  const mutationOptions = getUpdateCollectedFieldMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * @summary Trigger manual fallback for a submission
 */
export const triggerManualFallback = (
  submissionId: string,
  options?: SecondParameter<typeof customFetch>,
  signal?: AbortSignal
) => {
  return customFetch<TriggerManualFallback200>(
    { url: `API_BASE_URL/api/submissions/${submissionId}/manual-fallback`, method: 'POST', signal },
    options
  )
}

export const getTriggerManualFallbackMutationOptions = <
  TError = TriggerManualFallback404 | TriggerManualFallback500,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof triggerManualFallback>>,
    TError,
    { submissionId: string },
    TContext
  >
  request?: SecondParameter<typeof customFetch>
}): UseMutationOptions<
  Awaited<ReturnType<typeof triggerManualFallback>>,
  TError,
  { submissionId: string },
  TContext
> => {
  const mutationKey = ['triggerManualFallback']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof triggerManualFallback>>,
    { submissionId: string }
  > = (props) => {
    const { submissionId } = props ?? {}

    return triggerManualFallback(submissionId, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type TriggerManualFallbackMutationResult = NonNullable<
  Awaited<ReturnType<typeof triggerManualFallback>>
>

export type TriggerManualFallbackMutationError = TriggerManualFallback404 | TriggerManualFallback500

/**
 * @summary Trigger manual fallback for a submission
 */
export const useTriggerManualFallback = <
  TError = TriggerManualFallback404 | TriggerManualFallback500,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof triggerManualFallback>>,
      TError,
      { submissionId: string },
      TContext
    >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof triggerManualFallback>>,
  TError,
  { submissionId: string },
  TContext
> => {
  const mutationOptions = getTriggerManualFallbackMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * @summary Mark review as completed
 */
export const markReviewCompleted = (
  submissionId: string,
  options?: SecondParameter<typeof customFetch>
) => {
  return customFetch<MarkReviewCompleted200>(
    { url: `API_BASE_URL/api/submissions/${submissionId}/review-completed`, method: 'PATCH' },
    options
  )
}

export const getMarkReviewCompletedMutationOptions = <
  TError = MarkReviewCompleted400 | MarkReviewCompleted404 | MarkReviewCompleted500,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof markReviewCompleted>>,
    TError,
    { submissionId: string },
    TContext
  >
  request?: SecondParameter<typeof customFetch>
}): UseMutationOptions<
  Awaited<ReturnType<typeof markReviewCompleted>>,
  TError,
  { submissionId: string },
  TContext
> => {
  const mutationKey = ['markReviewCompleted']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof markReviewCompleted>>,
    { submissionId: string }
  > = (props) => {
    const { submissionId } = props ?? {}

    return markReviewCompleted(submissionId, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type MarkReviewCompletedMutationResult = NonNullable<
  Awaited<ReturnType<typeof markReviewCompleted>>
>

export type MarkReviewCompletedMutationError =
  | MarkReviewCompleted400
  | MarkReviewCompleted404
  | MarkReviewCompleted500

/**
 * @summary Mark review as completed
 */
export const useMarkReviewCompleted = <
  TError = MarkReviewCompleted400 | MarkReviewCompleted404 | MarkReviewCompleted500,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof markReviewCompleted>>,
      TError,
      { submissionId: string },
      TContext
    >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof markReviewCompleted>>,
  TError,
  { submissionId: string },
  TContext
> => {
  const mutationOptions = getMarkReviewCompletedMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * @summary Mark consent as checked
 */
export const markConsentChecked = (
  submissionId: string,
  options?: SecondParameter<typeof customFetch>
) => {
  return customFetch<MarkConsentChecked200>(
    { url: `API_BASE_URL/api/submissions/${submissionId}/consent-checked`, method: 'PATCH' },
    options
  )
}

export const getMarkConsentCheckedMutationOptions = <
  TError = MarkConsentChecked400 | MarkConsentChecked404 | MarkConsentChecked500,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof markConsentChecked>>,
    TError,
    { submissionId: string },
    TContext
  >
  request?: SecondParameter<typeof customFetch>
}): UseMutationOptions<
  Awaited<ReturnType<typeof markConsentChecked>>,
  TError,
  { submissionId: string },
  TContext
> => {
  const mutationKey = ['markConsentChecked']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof markConsentChecked>>,
    { submissionId: string }
  > = (props) => {
    const { submissionId } = props ?? {}

    return markConsentChecked(submissionId, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type MarkConsentCheckedMutationResult = NonNullable<
  Awaited<ReturnType<typeof markConsentChecked>>
>

export type MarkConsentCheckedMutationError =
  | MarkConsentChecked400
  | MarkConsentChecked404
  | MarkConsentChecked500

/**
 * @summary Mark consent as checked
 */
export const useMarkConsentChecked = <
  TError = MarkConsentChecked400 | MarkConsentChecked404 | MarkConsentChecked500,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof markConsentChecked>>,
      TError,
      { submissionId: string },
      TContext
    >
    request?: SecondParameter<typeof customFetch>
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof markConsentChecked>>,
  TError,
  { submissionId: string },
  TContext
> => {
  const mutationOptions = getMarkConsentCheckedMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
